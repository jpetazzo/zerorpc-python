#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Open Source Initiative OSI - The MIT License (MIT):Licensing
#
# The MIT License (MIT)
# Copyright (c) 2012 DotCloud Inc (opensource@dotcloud.com)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do
# so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import argparse
import json
import sys
import inspect
import os
import random
import gevent
import traceback
from pprint import pprint

import zerorpc
from zerorpc import zmq


parser = argparse.ArgumentParser(
        description='Make a zerorpc call to a remote service.'
        )

client_or_server = parser.add_mutually_exclusive_group()
client_or_server.add_argument('--client', action='store_true', default=True,
        help='remote procedure call mode (default)')
client_or_server.add_argument('--server', action='store_false', dest='client',
        help='turn a given python module into a server')

parser.add_argument('--debug', default=False, action='store_true')
parser.add_argument('--connect', action='append', metavar='address',
                    help='specify address to connect to. Can be specified \
                    multiple times and in conjunction with --bind')
parser.add_argument('--bind', action='append', metavar='address',
                    help='specify address to listen to. Can be specified \
                    multiple times and in conjunction with --connect')
parser.add_argument('--timeout', default=30, metavar='seconds', type=int,
                    help='abort request after X seconds. \
                    (default: 30s, --client only)')
parser.add_argument('--heartbeat', default=5, metavar='seconds', type=int,
                    help='heartbeat frequency. You should always use \
                    the same frequency as the server. (default: 5s)')
parser.add_argument('-j', '--json', default=False, action='store_true',
                    help='arguments are in JSON format and will be be parsed \
                    before being sent to the remote')
parser.add_argument('-pj', '--print-json', default=False, action='store_true',
                    help='print result in JSON format.')
parser.add_argument('-?', '--inspect', default=False, action='store_true',
                    help='retrieve detailed informations for the given \
                    remote (cf: command) method. If not method, display \
                    a list of remote methods signature. (only for --client).')
parser.add_argument('--active-hb', default=False, action='store_true',
                    help='enable active heartbeat. The default is to \
                    wait for the server to send the first heartbeat')
parser.add_argument('address', nargs='?', help='address to connect to. Skip \
                    this if you specified --connect or --bind at least once')
parser.add_argument('command', nargs='?',
                    help='remote procedure to call if --client (default) or \
                    python module/class to load if --server. If no command is \
                    specified, a list of remote methods are displayed.')
parser.add_argument('params', nargs='*',
                    help='parameters for the remote call if --client \
                    (default)')


def setup_links(args, socket):
    if args.bind:
        for endpoint in args.bind:
            print 'binding to "{0}"'.format(endpoint)
            socket.bind(endpoint)
    addresses = []
    if args.address:
        addresses.append(args.address)
    if args.connect:
        addresses.extend(args.connect)
    for endpoint in addresses:
        print 'connecting to "{0}"'.format(endpoint)
        socket.connect(endpoint)


def run_server(args):
    server_obj_path = args.command

    sys.path.insert(0, os.getcwd())
    if '.' in server_obj_path:
        modulepath, objname = server_obj_path.rsplit('.', 1)
        module = __import__(modulepath, fromlist=[objname])
        server_obj = getattr(module, objname)
    else:
        server_obj = __import__(server_obj_path)

    if callable(server_obj):
        server_obj = server_obj()

    server = zerorpc.Server(server_obj, heartbeat=args.heartbeat)
    setup_links(args, server)
    print 'serving "{0}"'.format(server_obj_path)
    return server.run()


# this function does a really intricate job to keep backward compatibility
# with a previous version of zerorpc, and lazily retrieving results if possible
def zerorpc_inspect(client, method=None, long_doc=True, include_argspec=True):
    try:
        remote_detailled_methods = client._zerorpc_inspect(method,
                long_doc)['methods']

        if include_argspec:
            r = [(name + (inspect.formatargspec(*argspec) if argspec else
                '(...)'), doc if doc else '<undocumented>')
                for name, argspec, doc in remote_detailled_methods]
        else:
            r = [(name, doc if doc else '<undocumented>')
                    for name, argspec, doc in remote_detailled_methods]

        longest_name_len = max(len(name) for name, doc in r)
        return (longest_name_len, r)
    except (zerorpc.RemoteError, NameError):
        pass

    if method is None:
        remote_methods = client._zerorpc_list()
    else:
        remote_methods = [method]

    def remote_detailled_methods():
        for name in remote_methods:
            if include_argspec:
                argspec = client._zerorpc_args(name)
            else:
                argspec = None
            docstring = client._zerorpc_help(name)
            if docstring and not long_doc:
                docstring = docstring.split('\n', 1)[0]
            yield (name, argspec, docstring if docstring else '<undocumented>')

    if not include_argspec:
        longest_name_len = max(len(name) for name in remote_methods)
        return (longest_name_len, ((name, doc) for name, argspec, doc in
            remote_detailled_methods()))

    r = [(name + (inspect.formatargspec(*argspec)
            if argspec else '(...)'), doc)
            for name, argspec, doc in remote_detailled_methods()]
    longest_name_len = max(len(name) for name, doc in r)
    return (longest_name_len, r)


def context_shell(client):
    try:
        # We want to avoid making zerorpc dependent upon gevent_subprocess until
        # the context feature conquer the world and become indispensable.
        import gevent_subprocess
    except ImportError as e:
        print e
        print 'You might want to install gevent_subprocess to',
        print 'use the sub shell feature of the zerorpc''s cli.'
        print 'ex: pip install gevent_subprocess'
        return -1

    # This ugly broken proxy assume that you will never try to run more than one
    # zerorpc client at a time... No one should take this code as a good
    # practice! Since the whole thing is just some convenience for zerorpc's cli
    # it shouldn't be so much a big deal anyway.

    context_name = client._zerorpc_name()
    class Proxy(zerorpc.SocketBase):
        def __init__(self, channel):
            self._channel = channel
            self._zmqid = None
            self._msgid = None
            self._sender_task = None
            self._recver_task = None
            super(Proxy, self).__init__(zmq.XREP)

        def close(self):
            if self._sender_task:
                self._sender_task.kill()
            if self._recver_task:
                self._recver_task.kill()
            super(Proxy, self).close()

        def _sender(self):
            while True:
                event = self._events.recv()
                self._zmqid = event.header.get('zmqid', None)
                self._msgid = event.header.get('message_id', None)
                self._channel.emit_event(event)

        def _recver(self):
            while True:
                event = self._channel.recv()
                self._events.emit_event(event, self._zmqid)

        def run(self):
            self._sender_task = gevent.spawn(self._sender)
            self._recver_task = gevent.spawn(self._recver)

        def _sender_error(self):
            # reply in loop that the context is closed...
            while True:
                event = self._events.recv()
                self._zmqid = event.header.get('zmqid', None)
                self._msgid = event.header.get('message_id', None)
                self._events.emit('ERR', ('ContextClosed',
                    'Context closed! You might want to exit your sub-shell and open'
                    ' another one.', None),
                        dict(zmqid=self._zmqid, response_to=self._msgid))

        def error_mode(self, e):
            if self._sender_task:
                self._sender_task.kill()
                self._sender_task = None
            if self._recver_task:
                self._recver_task.kill()
                self._recver_task = None
            # send an error over the wire to stop any pending zerorpc client on
            # the other side of the IPC.
            self._events.emit('ERR', (type(e).__name__, str(e), None),
                        dict(zmqid=self._zmqid, response_to=self._msgid))
            self._sender_task = gevent.spawn(self._sender_error)

    # So here, we roughly inter-connect an IPC to the remote Context.
    ipc_endpoint = '/tmp/zerorpc_context_proxy_{0}'.format(random.random())
    proxy_endpoint = 'ipc://{0}'.format(ipc_endpoint)
    client_events = client._multiplexer._events
    client._multiplexer.close()
    proxy = Proxy(client_events)
    proxy.bind(proxy_endpoint)
    proxy.run()

    print 'You are in a subshell, zerorpc\'s cli will now connect to this sub rpc',
    print 'context by default. To close the context, simply exit the sub-shell.'
    print 'ZERORPC_CONNECT_TO="{0}"'.format(proxy_endpoint)
    print '-- context "{0}" open'.format(context_name)
    print
    env = os.environ.copy()
    env['ZERORPC_CONNECT_TO'] = proxy_endpoint
    subshell = gevent_subprocess.Popen(os.environ.get('SHELL', 'sh'), env=env)
    try:
        subshell.wait()
    except Exception as e:
        print '-- '
        print '-- context "{0}" closed on error: {1}'.format(context_name, e)
        proxy.error_mode(e)
        subshell.wait()
    else:
        print '-- context "{0}" closed'.format(context_name)
    finally:
        try:
            os.unlink(ipc_endpoint)
        except OSError:
            pass


def run_repl(args, client):
    while True:
        try:
            line = raw_input('{0}> '.format(args.address))
        except EOFError:
            break
        except KeyboardInterrupt:
            break
        try:
            result = client._zerorpc_debug(line)
            if result:
                print repr(result['result'])
        except:
            traceback.print_exc()
    

def run_client(args):
    client = zerorpc.Client(timeout=args.timeout, heartbeat=args.heartbeat,
            passive_heartbeat=not args.active_hb)
    setup_links(args, client)
    if args.debug and not args.command:
        run_repl(args, client)
        return        
    if not args.command:
        (longest_name_len, detailled_methods) = zerorpc_inspect(client,
                long_doc=False, include_argspec=args.inspect)
        if args.inspect:
            for (name, doc) in detailled_methods:
                print name
        else:
            for (name, doc) in detailled_methods:
                print '{0} {1}'.format(name.ljust(longest_name_len), doc)
        return
    if args.inspect:
        (longest_name_len, detailled_methods) = zerorpc_inspect(client,
                method=args.command)
        (name, doc) = detailled_methods[0]
        print '\n{0}\n\n{1}\n'.format(name, doc)
        return
    if args.json:
        call_args = [json.loads(x) for x in args.params]
    else:
        call_args = args.params
    results = client(args.command, *call_args)
    if isinstance(results, zerorpc.ClientBase):
        # context
        return context_shell(results)
    elif getattr(results, 'next', None) is not None:
        # streaming responses
        if args.print_json:
            first = True
            sys.stdout.write('[')
            for result in results:
                if first:
                    first = False
                else:
                    sys.stdout.write(',')
                json.dump(result, sys.stdout)
            sys.stdout.write(']')
        else:
            for result in results:
                pprint(result)
    else:
        # req/rep
        if args.print_json:
            json.dump(results, sys.stdout)
        else:
            pprint(results)


def main():
    args = parser.parse_args()

    proxy_endpoint = os.environ.get('ZERORPC_CONNECT_TO', None)
    if args.bind or args.connect or proxy_endpoint:
        if args.command:
            args.params.insert(0, args.command)
        args.command = args.address
        args.address = None

    if not (args.bind or args.connect or args.address):
        if not proxy_endpoint:
            parser.print_help()
            return -1
        args.address = proxy_endpoint

    if args.client:
        return run_client(args)

    if not args.command:
        parser.print_help()
        return -1

    return run_server(args)

if __name__ == '__main__':
    exit(main())
